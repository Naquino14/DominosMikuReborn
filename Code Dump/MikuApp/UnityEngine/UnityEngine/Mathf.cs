using System;
using System.Runtime.CompilerServices;

namespace UnityEngine
{
	public struct Mathf
	{
		public const float PI = (float)Math.PI;

		public const float Infinity = float.PositiveInfinity;

		public const float NegativeInfinity = float.NegativeInfinity;

		public const float Deg2Rad = (float)Math.PI / 180f;

		public const float Rad2Deg = 57.29578f;

		public const float Epsilon = 1.17549435E-38f;

		public static float Sin(float f)
		{
			return (float)/*Error near IL_0001: Stack underflow*/;
		}

		public static float Cos(float f)
		{
			return (float)/*Error near IL_0001: Stack underflow*/;
		}

		public static float Acos(float f)
		{
			return (float)/*Error near IL_0001: Stack underflow*/;
		}

		public static float Sqrt(float f)
		{
			return (float)/*Error near IL_0001: Stack underflow*/;
		}

		public static float Abs(float f)
		{
			return (float)/*Error near IL_0001: Stack underflow*/;
		}

		public static int Abs(int value)
		{
			return (int)/*Error near IL_0001: Stack underflow*/;
		}

		public static float Min(float a, float b)
		{
			return (float)/*Error near IL_0001: Stack underflow*/;
		}

		public static float Min(params float[] values)
		{
			return (float)/*Error near IL_0001: Stack underflow*/;
		}

		public static int Min(int a, int b)
		{
			return (int)/*Error near IL_0001: Stack underflow*/;
		}

		public static float Max(float a, float b)
		{
			return (float)/*Error near IL_0001: Stack underflow*/;
		}

		public static float Max(params float[] values)
		{
			return (float)/*Error near IL_0001: Stack underflow*/;
		}

		public static int Max(int a, int b)
		{
			return (int)/*Error near IL_0001: Stack underflow*/;
		}

		public static float Ceil(float f)
		{
			return (float)/*Error near IL_0001: Stack underflow*/;
		}

		public static float Floor(float f)
		{
			return (float)/*Error near IL_0001: Stack underflow*/;
		}

		public static float Round(float f)
		{
			return (float)/*Error near IL_0001: Stack underflow*/;
		}

		public static int CeilToInt(float f)
		{
			return (int)/*Error near IL_0001: Stack underflow*/;
		}

		public static int FloorToInt(float f)
		{
			return (int)/*Error near IL_0001: Stack underflow*/;
		}

		public static int RoundToInt(float f)
		{
			return (int)/*Error near IL_0001: Stack underflow*/;
		}

		public static float Sign(float f)
		{
			return (float)/*Error near IL_0001: Stack underflow*/;
		}

		public static float Clamp(float value, float min, float max)
		{
			return (float)/*Error near IL_0001: Stack underflow*/;
		}

		public static float Clamp01(float value)
		{
			return (float)/*Error near IL_0001: Stack underflow*/;
		}

		public static float Lerp(float from, float to, float t)
		{
			return (float)/*Error near IL_0001: Stack underflow*/;
		}

		public static bool Approximately(float a, float b)
		{
			return (byte)/*Error near IL_0001: Stack underflow*/ != 0;
		}

		[MethodImpl(4096)]
		[WrapperlessIcall]
		public static extern bool IsPowerOfTwo(int value);
	}
}
